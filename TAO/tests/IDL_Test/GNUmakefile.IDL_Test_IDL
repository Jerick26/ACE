# -*- Makefile -*-
#----------------------------------------------------------------------------
#       GNU Makefile
#
# @file GNUmakefile.IDL_Test_IDL
#
# $Id: gnu.mpd 95691 2012-04-10 20:11:35Z mitza $
#
# This file was automatically generated by MPC.  Any changes made directly to
# this file will be lost the next time it is generated.
#
#----------------------------------------------------------------------------
MAKEFILE         = GNUmakefile.IDL_Test_IDL
DEPENDENCY_FILE  = .depend.IDL_Test_IDL


LIB_PREFIX      ?= lib

TAO_ROOT  ?= $(ACE_ROOT)/TAO

FILES = \


#----------------------------------------------------------------------------
#       Include macros and targets
#----------------------------------------------------------------------------
TAO_IDL = ../../../bin/tao_idl
TAO_IDL_DEP = ../../../bin/tao_idl$(EXEEXT)
TAO_IDLFLAGS = -Wb,pre_include=ace/pre.h -Wb,post_include=ace/post.h -I../..$(if $(ARCH), -g $(call ADD_QUOTE,$(call ADD_ARCH,$(ACE_ROOT)/bin/ace_gperf)))

PRJ_TYPE = library

COLLAPSE_SLASHES = $(if $(findstring //,$(1)),$(call COLLAPSE_SLASHES,$(subst //,/,$(1))),$(1))
INSLIB ?= $(call COLLAPSE_SLASHES,.)
ifeq ($(INSLIB),.)
  ifeq ($(CURDIR),)
    ifeq ($(PWD),)
      PWD=$(shell pwd)
    endif
  else
    PWD=$(CURDIR)
  endif
  INSLIB = $(PWD)
endif
OUTPUT_DIRECTORY = $(INSLIB)

include $(ACE_ROOT)/include/makeinclude/wrapper_macros.GNU

include $(TAO_ROOT)/rules.tao.GNU

GNUACE_PROJECT_VERSION ?= $(ACE_VERSION)

# To build multiple targets in the same directory on AIX, it works
# best to have a template directory per project.
# The compiler/linker isn't too smart about instantiating templates...
ifdef TEMPINCDIR
TEMPINCDIR := $(TEMPINCDIR)/IDL_Test_IDL
all: $(TEMPINCDIR)
endif

ifneq ($(OUTPUT_DIRECTORY),)
.PHONY: create_output_directory.local
all: create_output_directory.local
create_output_directory.local:
	-@$(MKDIR) "$(OUTPUT_DIRECTORY)" $(ACE_NUL_STDERR)
endif

LIBCHECK = 1
ifeq ($(corba_messaging),1)
ifneq ($(LIBCHECK), 1)
  all: lib_warning
endif
else
  all: require_warning
endif

ifeq ($(corba_messaging),1)
else
  all: require_warning
endif

include $(ACE_ROOT)/include/makeinclude/macros.GNU
include $(ACE_ROOT)/include/makeinclude/rules.common.GNU
include $(ACE_ROOT)/include/makeinclude/rules.nonested.GNU
include $(ACE_ROOT)/include/makeinclude/rules.local.GNU
ifeq ($(VXWORKSLINK),1)
include $(TGT_DIR)/h/make/rules.$(PRJ_TYPE)
endif

ifeq ($(VXWORKSLINK),1)
LDLIBPATH     = -L. -L../../../lib
else
LDFLAGS      += -L. $(if $(ARCH),-L./$(ARCH)) -L../../../lib $(if $(ARCH),-L../../../lib/$(ARCH))
endif
CPPFLAGS     += -I../../.. -I../..
ifeq ($(static_libs),1)
  CPPFLAGS += -DACE_AS_STATIC_LIBS -DTAO_AS_STATIC_LIBS
endif

#----------------------------------------------------------------------------
#       Local targets
#----------------------------------------------------------------------------
lib_warning:
	@echo IDL_Test_IDL will not be built due to the following missing library: $(LIBCHECK) >&2

ifneq ($(corba_messaging),1)
requires_disabled_macros += corba_messaging
endif
require_warning:
	@echo IDL_Test_IDL will not be built due to the following disabled make macros: $(requires_disabled_macros)>&2

## Some OS's have /bin/test others only have /usr/bin/test
ifeq ($(wildcard /bin/test), /bin/test)
  TEST_EXE = /bin/test
else
ifeq ($(wildcard /usr/bin/test), /usr/bin/test)
  TEST_EXE = /usr/bin/test
endif
endif

SPACE = $(should_be_unset) $(should_be_unset)
DYLD_LIBRARY_PATH := $(DYLD_LIBRARY_PATH):../../../lib$(if $(ARCH),:../../../lib/$(ARCH))
LD_LIBRARY_PATH   := $(LD_LIBRARY_PATH):../../../lib$(if $(ARCH),:../../../lib/$(ARCH))
SHLIB_PATH        := $(SHLIB_PATH):../../../lib$(if $(ARCH),:../../../lib/$(ARCH))
LIBPATH           := $(LIBPATH):../../../lib$(if $(ARCH),:../../../lib/$(ARCH))
PATH              := $(PATH):../../../lib$(if $(ARCH),:../../../lib/$(ARCH))

GENERATED_DIRTY += attributeC.inl attributeS.h attributeS_T.h attributeC.h TAO_IDL_TEST_stub_export.h attributeS.cpp attributeC.cpp attributeS_T.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "attribute.idl" -nt "attributeC.inl" 2> /dev/null || $(TEST_EXE) "attribute.idl" -nt "attributeS.h" 2> /dev/null || $(TEST_EXE) "attribute.idl" -nt "attributeS_T.h" 2> /dev/null || $(TEST_EXE) "attribute.idl" -nt "attributeC.h" 2> /dev/null || $(TEST_EXE) "attribute.idl" -nt "TAO_IDL_TEST_stub_export.h" 2> /dev/null || $(TEST_EXE) "attribute.idl" -nt "attributeS.cpp" 2> /dev/null || $(TEST_EXE) "attribute.idl" -nt "attributeC.cpp" 2> /dev/null || $(TEST_EXE) "attribute.idl" -nt "attributeS_T.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "attributeC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "attributeS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "attributeS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "attributeC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "TAO_IDL_TEST_stub_export.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "attributeS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "attributeC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "attributeS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "attributeC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "attributeS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "attributeS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "attributeC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "TAO_IDL_TEST_stub_export.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "attributeS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "attributeC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "attributeS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "attributeC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "attributeS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "attributeS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "attributeC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "TAO_IDL_TEST_stub_export.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "attributeS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "attributeC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "attributeS_T.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
attributeC.inl attributeS.h attributeS_T.h attributeC.h TAO_IDL_TEST_stub_export.h attributeS.cpp attributeC.cpp attributeS_T.cpp: attribute.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gxhst attribute.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
attributeC.inl attributeS.h attributeS_T.h attributeC.h TAO_IDL_TEST_stub_export.h attributeS.cpp attributeC.cpp attributeS_T.cpp: $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += Bug_2350_RegressionC.inl Bug_2350_RegressionS.h Bug_2350_RegressionS_T.h Bug_2350_RegressionC.h Bug_2350_RegressionS.cpp Bug_2350_RegressionC.cpp Bug_2350_RegressionS_T.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "Bug_2350_Regression.idl" -nt "Bug_2350_RegressionC.inl" 2> /dev/null || $(TEST_EXE) "Bug_2350_Regression.idl" -nt "Bug_2350_RegressionS.h" 2> /dev/null || $(TEST_EXE) "Bug_2350_Regression.idl" -nt "Bug_2350_RegressionS_T.h" 2> /dev/null || $(TEST_EXE) "Bug_2350_Regression.idl" -nt "Bug_2350_RegressionC.h" 2> /dev/null || $(TEST_EXE) "Bug_2350_Regression.idl" -nt "Bug_2350_RegressionS.cpp" 2> /dev/null || $(TEST_EXE) "Bug_2350_Regression.idl" -nt "Bug_2350_RegressionC.cpp" 2> /dev/null || $(TEST_EXE) "Bug_2350_Regression.idl" -nt "Bug_2350_RegressionS_T.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_2350_RegressionC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_2350_RegressionS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_2350_RegressionS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_2350_RegressionC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_2350_RegressionS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_2350_RegressionC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_2350_RegressionS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_2350_RegressionC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_2350_RegressionS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_2350_RegressionS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_2350_RegressionC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_2350_RegressionS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_2350_RegressionC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_2350_RegressionS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_2350_RegressionC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_2350_RegressionS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_2350_RegressionS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_2350_RegressionC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_2350_RegressionS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_2350_RegressionC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_2350_RegressionS_T.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
Bug_2350_RegressionC.inl Bug_2350_RegressionS.h Bug_2350_RegressionS_T.h Bug_2350_RegressionC.h Bug_2350_RegressionS.cpp Bug_2350_RegressionC.cpp Bug_2350_RegressionS_T.cpp: Bug_2350_Regression.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h Bug_2350_Regression.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
Bug_2350_RegressionC.inl Bug_2350_RegressionS.h Bug_2350_RegressionS_T.h Bug_2350_RegressionC.h Bug_2350_RegressionS.cpp Bug_2350_RegressionC.cpp Bug_2350_RegressionS_T.cpp: $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += Bug_2577_RegressionC.inl Bug_2577_RegressionS.h Bug_2577_RegressionS_T.h Bug_2577_RegressionC.h Bug_2577_RegressionS.cpp Bug_2577_RegressionC.cpp Bug_2577_RegressionS_T.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "Bug_2577_Regression.idl" -nt "Bug_2577_RegressionC.inl" 2> /dev/null || $(TEST_EXE) "Bug_2577_Regression.idl" -nt "Bug_2577_RegressionS.h" 2> /dev/null || $(TEST_EXE) "Bug_2577_Regression.idl" -nt "Bug_2577_RegressionS_T.h" 2> /dev/null || $(TEST_EXE) "Bug_2577_Regression.idl" -nt "Bug_2577_RegressionC.h" 2> /dev/null || $(TEST_EXE) "Bug_2577_Regression.idl" -nt "Bug_2577_RegressionS.cpp" 2> /dev/null || $(TEST_EXE) "Bug_2577_Regression.idl" -nt "Bug_2577_RegressionC.cpp" 2> /dev/null || $(TEST_EXE) "Bug_2577_Regression.idl" -nt "Bug_2577_RegressionS_T.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_2577_RegressionC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_2577_RegressionS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_2577_RegressionS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_2577_RegressionC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_2577_RegressionS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_2577_RegressionC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_2577_RegressionS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_2577_RegressionC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_2577_RegressionS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_2577_RegressionS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_2577_RegressionC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_2577_RegressionS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_2577_RegressionC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_2577_RegressionS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_2577_RegressionC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_2577_RegressionS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_2577_RegressionS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_2577_RegressionC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_2577_RegressionS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_2577_RegressionC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_2577_RegressionS_T.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
Bug_2577_RegressionC.inl Bug_2577_RegressionS.h Bug_2577_RegressionS_T.h Bug_2577_RegressionC.h Bug_2577_RegressionS.cpp Bug_2577_RegressionC.cpp Bug_2577_RegressionS_T.cpp: Bug_2577_Regression.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h Bug_2577_Regression.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
Bug_2577_RegressionC.inl Bug_2577_RegressionS.h Bug_2577_RegressionS_T.h Bug_2577_RegressionC.h Bug_2577_RegressionS.cpp Bug_2577_RegressionC.cpp Bug_2577_RegressionS_T.cpp: $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += Bug_2582_RegressionC.inl Bug_2582_RegressionS.h Bug_2582_RegressionS_T.h Bug_2582_RegressionC.h Bug_2582_RegressionS.cpp Bug_2582_RegressionC.cpp Bug_2582_RegressionS_T.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "Bug_2582_Regression.idl" -nt "Bug_2582_RegressionC.inl" 2> /dev/null || $(TEST_EXE) "Bug_2582_Regression.idl" -nt "Bug_2582_RegressionS.h" 2> /dev/null || $(TEST_EXE) "Bug_2582_Regression.idl" -nt "Bug_2582_RegressionS_T.h" 2> /dev/null || $(TEST_EXE) "Bug_2582_Regression.idl" -nt "Bug_2582_RegressionC.h" 2> /dev/null || $(TEST_EXE) "Bug_2582_Regression.idl" -nt "Bug_2582_RegressionS.cpp" 2> /dev/null || $(TEST_EXE) "Bug_2582_Regression.idl" -nt "Bug_2582_RegressionC.cpp" 2> /dev/null || $(TEST_EXE) "Bug_2582_Regression.idl" -nt "Bug_2582_RegressionS_T.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_2582_RegressionC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_2582_RegressionS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_2582_RegressionS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_2582_RegressionC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_2582_RegressionS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_2582_RegressionC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_2582_RegressionS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_2582_RegressionC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_2582_RegressionS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_2582_RegressionS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_2582_RegressionC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_2582_RegressionS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_2582_RegressionC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_2582_RegressionS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_2582_RegressionC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_2582_RegressionS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_2582_RegressionS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_2582_RegressionC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_2582_RegressionS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_2582_RegressionC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_2582_RegressionS_T.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
Bug_2582_RegressionC.inl Bug_2582_RegressionS.h Bug_2582_RegressionS_T.h Bug_2582_RegressionC.h Bug_2582_RegressionS.cpp Bug_2582_RegressionC.cpp Bug_2582_RegressionS_T.cpp: Bug_2582_Regression.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h Bug_2582_Regression.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
Bug_2582_RegressionC.inl Bug_2582_RegressionS.h Bug_2582_RegressionS_T.h Bug_2582_RegressionC.h Bug_2582_RegressionS.cpp Bug_2582_RegressionC.cpp Bug_2582_RegressionS_T.cpp: $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += Bug_2583_RegressionC.inl Bug_2583_RegressionS.h Bug_2583_RegressionS_T.h Bug_2583_RegressionC.h Bug_2583_RegressionS.cpp Bug_2583_RegressionC.cpp Bug_2583_RegressionS_T.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "Bug_2583_Regression.idl" -nt "Bug_2583_RegressionC.inl" 2> /dev/null || $(TEST_EXE) "Bug_2583_Regression.idl" -nt "Bug_2583_RegressionS.h" 2> /dev/null || $(TEST_EXE) "Bug_2583_Regression.idl" -nt "Bug_2583_RegressionS_T.h" 2> /dev/null || $(TEST_EXE) "Bug_2583_Regression.idl" -nt "Bug_2583_RegressionC.h" 2> /dev/null || $(TEST_EXE) "Bug_2583_Regression.idl" -nt "Bug_2583_RegressionS.cpp" 2> /dev/null || $(TEST_EXE) "Bug_2583_Regression.idl" -nt "Bug_2583_RegressionC.cpp" 2> /dev/null || $(TEST_EXE) "Bug_2583_Regression.idl" -nt "Bug_2583_RegressionS_T.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_2583_RegressionC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_2583_RegressionS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_2583_RegressionS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_2583_RegressionC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_2583_RegressionS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_2583_RegressionC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_2583_RegressionS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_2583_RegressionC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_2583_RegressionS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_2583_RegressionS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_2583_RegressionC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_2583_RegressionS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_2583_RegressionC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_2583_RegressionS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_2583_RegressionC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_2583_RegressionS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_2583_RegressionS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_2583_RegressionC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_2583_RegressionS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_2583_RegressionC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_2583_RegressionS_T.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
Bug_2583_RegressionC.inl Bug_2583_RegressionS.h Bug_2583_RegressionS_T.h Bug_2583_RegressionC.h Bug_2583_RegressionS.cpp Bug_2583_RegressionC.cpp Bug_2583_RegressionS_T.cpp: Bug_2583_Regression.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h Bug_2583_Regression.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
Bug_2583_RegressionC.inl Bug_2583_RegressionS.h Bug_2583_RegressionS_T.h Bug_2583_RegressionC.h Bug_2583_RegressionS.cpp Bug_2583_RegressionC.cpp Bug_2583_RegressionS_T.cpp: $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += Bug_2616_RegressionC.inl Bug_2616_RegressionS.h Bug_2616_RegressionS_T.h Bug_2616_RegressionC.h Bug_2616_RegressionS.cpp Bug_2616_RegressionC.cpp Bug_2616_RegressionS_T.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "Bug_2616_Regression.idl" -nt "Bug_2616_RegressionC.inl" 2> /dev/null || $(TEST_EXE) "Bug_2616_Regression.idl" -nt "Bug_2616_RegressionS.h" 2> /dev/null || $(TEST_EXE) "Bug_2616_Regression.idl" -nt "Bug_2616_RegressionS_T.h" 2> /dev/null || $(TEST_EXE) "Bug_2616_Regression.idl" -nt "Bug_2616_RegressionC.h" 2> /dev/null || $(TEST_EXE) "Bug_2616_Regression.idl" -nt "Bug_2616_RegressionS.cpp" 2> /dev/null || $(TEST_EXE) "Bug_2616_Regression.idl" -nt "Bug_2616_RegressionC.cpp" 2> /dev/null || $(TEST_EXE) "Bug_2616_Regression.idl" -nt "Bug_2616_RegressionS_T.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_2616_RegressionC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_2616_RegressionS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_2616_RegressionS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_2616_RegressionC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_2616_RegressionS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_2616_RegressionC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_2616_RegressionS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_2616_RegressionC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_2616_RegressionS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_2616_RegressionS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_2616_RegressionC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_2616_RegressionS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_2616_RegressionC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_2616_RegressionS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_2616_RegressionC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_2616_RegressionS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_2616_RegressionS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_2616_RegressionC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_2616_RegressionS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_2616_RegressionC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_2616_RegressionS_T.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
Bug_2616_RegressionC.inl Bug_2616_RegressionS.h Bug_2616_RegressionS_T.h Bug_2616_RegressionC.h Bug_2616_RegressionS.cpp Bug_2616_RegressionC.cpp Bug_2616_RegressionS_T.cpp: Bug_2616_Regression.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h Bug_2616_Regression.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
Bug_2616_RegressionC.inl Bug_2616_RegressionS.h Bug_2616_RegressionS_T.h Bug_2616_RegressionC.h Bug_2616_RegressionS.cpp Bug_2616_RegressionC.cpp Bug_2616_RegressionS_T.cpp: $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += Bug_2619_RegressionC.inl Bug_2619_RegressionS.h Bug_2619_RegressionS_T.h Bug_2619_RegressionC.h Bug_2619_RegressionS.cpp Bug_2619_RegressionC.cpp Bug_2619_RegressionS_T.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "Bug_2619_Regression.idl" -nt "Bug_2619_RegressionC.inl" 2> /dev/null || $(TEST_EXE) "Bug_2619_Regression.idl" -nt "Bug_2619_RegressionS.h" 2> /dev/null || $(TEST_EXE) "Bug_2619_Regression.idl" -nt "Bug_2619_RegressionS_T.h" 2> /dev/null || $(TEST_EXE) "Bug_2619_Regression.idl" -nt "Bug_2619_RegressionC.h" 2> /dev/null || $(TEST_EXE) "Bug_2619_Regression.idl" -nt "Bug_2619_RegressionS.cpp" 2> /dev/null || $(TEST_EXE) "Bug_2619_Regression.idl" -nt "Bug_2619_RegressionC.cpp" 2> /dev/null || $(TEST_EXE) "Bug_2619_Regression.idl" -nt "Bug_2619_RegressionS_T.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_2619_RegressionC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_2619_RegressionS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_2619_RegressionS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_2619_RegressionC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_2619_RegressionS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_2619_RegressionC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_2619_RegressionS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_2619_RegressionC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_2619_RegressionS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_2619_RegressionS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_2619_RegressionC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_2619_RegressionS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_2619_RegressionC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_2619_RegressionS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_2619_RegressionC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_2619_RegressionS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_2619_RegressionS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_2619_RegressionC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_2619_RegressionS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_2619_RegressionC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_2619_RegressionS_T.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
Bug_2619_RegressionC.inl Bug_2619_RegressionS.h Bug_2619_RegressionS_T.h Bug_2619_RegressionC.h Bug_2619_RegressionS.cpp Bug_2619_RegressionC.cpp Bug_2619_RegressionS_T.cpp: Bug_2619_Regression.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h Bug_2619_Regression.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
Bug_2619_RegressionC.inl Bug_2619_RegressionS.h Bug_2619_RegressionS_T.h Bug_2619_RegressionC.h Bug_2619_RegressionS.cpp Bug_2619_RegressionC.cpp Bug_2619_RegressionS_T.cpp: $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += Bug_3243_RegressionC.inl Bug_3243_RegressionS.h Bug_3243_RegressionS_T.h Bug_3243_RegressionC.h Bug_3243_RegressionS.cpp Bug_3243_RegressionC.cpp Bug_3243_RegressionS_T.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "Bug_3243_Regression.idl" -nt "Bug_3243_RegressionC.inl" 2> /dev/null || $(TEST_EXE) "Bug_3243_Regression.idl" -nt "Bug_3243_RegressionS.h" 2> /dev/null || $(TEST_EXE) "Bug_3243_Regression.idl" -nt "Bug_3243_RegressionS_T.h" 2> /dev/null || $(TEST_EXE) "Bug_3243_Regression.idl" -nt "Bug_3243_RegressionC.h" 2> /dev/null || $(TEST_EXE) "Bug_3243_Regression.idl" -nt "Bug_3243_RegressionS.cpp" 2> /dev/null || $(TEST_EXE) "Bug_3243_Regression.idl" -nt "Bug_3243_RegressionC.cpp" 2> /dev/null || $(TEST_EXE) "Bug_3243_Regression.idl" -nt "Bug_3243_RegressionS_T.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_3243_RegressionC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_3243_RegressionS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_3243_RegressionS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_3243_RegressionC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_3243_RegressionS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_3243_RegressionC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_3243_RegressionS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_3243_RegressionC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_3243_RegressionS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_3243_RegressionS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_3243_RegressionC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_3243_RegressionS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_3243_RegressionC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_3243_RegressionS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_3243_RegressionC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_3243_RegressionS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_3243_RegressionS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_3243_RegressionC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_3243_RegressionS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_3243_RegressionC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_3243_RegressionS_T.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
Bug_3243_RegressionC.inl Bug_3243_RegressionS.h Bug_3243_RegressionS_T.h Bug_3243_RegressionC.h Bug_3243_RegressionS.cpp Bug_3243_RegressionC.cpp Bug_3243_RegressionS_T.cpp: Bug_3243_Regression.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h Bug_3243_Regression.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
Bug_3243_RegressionC.inl Bug_3243_RegressionS.h Bug_3243_RegressionS_T.h Bug_3243_RegressionC.h Bug_3243_RegressionS.cpp Bug_3243_RegressionC.cpp Bug_3243_RegressionS_T.cpp: $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += Bug_3312_RegressionC.inl Bug_3312_RegressionS.h Bug_3312_RegressionS_T.h Bug_3312_RegressionC.h Bug_3312_RegressionS.cpp Bug_3312_RegressionC.cpp Bug_3312_RegressionS_T.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "Bug_3312_Regression.idl" -nt "Bug_3312_RegressionC.inl" 2> /dev/null || $(TEST_EXE) "Bug_3312_Regression.idl" -nt "Bug_3312_RegressionS.h" 2> /dev/null || $(TEST_EXE) "Bug_3312_Regression.idl" -nt "Bug_3312_RegressionS_T.h" 2> /dev/null || $(TEST_EXE) "Bug_3312_Regression.idl" -nt "Bug_3312_RegressionC.h" 2> /dev/null || $(TEST_EXE) "Bug_3312_Regression.idl" -nt "Bug_3312_RegressionS.cpp" 2> /dev/null || $(TEST_EXE) "Bug_3312_Regression.idl" -nt "Bug_3312_RegressionC.cpp" 2> /dev/null || $(TEST_EXE) "Bug_3312_Regression.idl" -nt "Bug_3312_RegressionS_T.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_3312_RegressionC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_3312_RegressionS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_3312_RegressionS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_3312_RegressionC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_3312_RegressionS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_3312_RegressionC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_3312_RegressionS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_3312_RegressionC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_3312_RegressionS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_3312_RegressionS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_3312_RegressionC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_3312_RegressionS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_3312_RegressionC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_3312_RegressionS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_3312_RegressionC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_3312_RegressionS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_3312_RegressionS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_3312_RegressionC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_3312_RegressionS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_3312_RegressionC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_3312_RegressionS_T.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
Bug_3312_RegressionC.inl Bug_3312_RegressionS.h Bug_3312_RegressionS_T.h Bug_3312_RegressionC.h Bug_3312_RegressionS.cpp Bug_3312_RegressionC.cpp Bug_3312_RegressionS_T.cpp: Bug_3312_Regression.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h Bug_3312_Regression.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
Bug_3312_RegressionC.inl Bug_3312_RegressionS.h Bug_3312_RegressionS_T.h Bug_3312_RegressionC.h Bug_3312_RegressionS.cpp Bug_3312_RegressionC.cpp Bug_3312_RegressionS_T.cpp: $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += Bug_3819_RegressionC.inl Bug_3819_RegressionS.h Bug_3819_RegressionS_T.h Bug_3819_RegressionC.h Bug_3819_RegressionS.cpp Bug_3819_RegressionC.cpp Bug_3819_RegressionS_T.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "Bug_3819_Regression.idl" -nt "Bug_3819_RegressionC.inl" 2> /dev/null || $(TEST_EXE) "Bug_3819_Regression.idl" -nt "Bug_3819_RegressionS.h" 2> /dev/null || $(TEST_EXE) "Bug_3819_Regression.idl" -nt "Bug_3819_RegressionS_T.h" 2> /dev/null || $(TEST_EXE) "Bug_3819_Regression.idl" -nt "Bug_3819_RegressionC.h" 2> /dev/null || $(TEST_EXE) "Bug_3819_Regression.idl" -nt "Bug_3819_RegressionS.cpp" 2> /dev/null || $(TEST_EXE) "Bug_3819_Regression.idl" -nt "Bug_3819_RegressionC.cpp" 2> /dev/null || $(TEST_EXE) "Bug_3819_Regression.idl" -nt "Bug_3819_RegressionS_T.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_3819_RegressionC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_3819_RegressionS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_3819_RegressionS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_3819_RegressionC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_3819_RegressionS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_3819_RegressionC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_3819_RegressionS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_3819_RegressionC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_3819_RegressionS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_3819_RegressionS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_3819_RegressionC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_3819_RegressionS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_3819_RegressionC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_3819_RegressionS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_3819_RegressionC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_3819_RegressionS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_3819_RegressionS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_3819_RegressionC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_3819_RegressionS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_3819_RegressionC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_3819_RegressionS_T.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
Bug_3819_RegressionC.inl Bug_3819_RegressionS.h Bug_3819_RegressionS_T.h Bug_3819_RegressionC.h Bug_3819_RegressionS.cpp Bug_3819_RegressionC.cpp Bug_3819_RegressionS_T.cpp: Bug_3819_Regression.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h Bug_3819_Regression.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
Bug_3819_RegressionC.inl Bug_3819_RegressionS.h Bug_3819_RegressionS_T.h Bug_3819_RegressionC.h Bug_3819_RegressionS.cpp Bug_3819_RegressionC.cpp Bug_3819_RegressionS_T.cpp: $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += Bug_3821_RegressionC.inl Bug_3821_RegressionS.h Bug_3821_RegressionS_T.h Bug_3821_RegressionC.h Bug_3821_RegressionS.cpp Bug_3821_RegressionC.cpp Bug_3821_RegressionS_T.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "Bug_3821_Regression.idl" -nt "Bug_3821_RegressionC.inl" 2> /dev/null || $(TEST_EXE) "Bug_3821_Regression.idl" -nt "Bug_3821_RegressionS.h" 2> /dev/null || $(TEST_EXE) "Bug_3821_Regression.idl" -nt "Bug_3821_RegressionS_T.h" 2> /dev/null || $(TEST_EXE) "Bug_3821_Regression.idl" -nt "Bug_3821_RegressionC.h" 2> /dev/null || $(TEST_EXE) "Bug_3821_Regression.idl" -nt "Bug_3821_RegressionS.cpp" 2> /dev/null || $(TEST_EXE) "Bug_3821_Regression.idl" -nt "Bug_3821_RegressionC.cpp" 2> /dev/null || $(TEST_EXE) "Bug_3821_Regression.idl" -nt "Bug_3821_RegressionS_T.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_3821_RegressionC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_3821_RegressionS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_3821_RegressionS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_3821_RegressionC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_3821_RegressionS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_3821_RegressionC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_3821_RegressionS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_3821_RegressionC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_3821_RegressionS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_3821_RegressionS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_3821_RegressionC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_3821_RegressionS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_3821_RegressionC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_3821_RegressionS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_3821_RegressionC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_3821_RegressionS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_3821_RegressionS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_3821_RegressionC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_3821_RegressionS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_3821_RegressionC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_3821_RegressionS_T.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
Bug_3821_RegressionC.inl Bug_3821_RegressionS.h Bug_3821_RegressionS_T.h Bug_3821_RegressionC.h Bug_3821_RegressionS.cpp Bug_3821_RegressionC.cpp Bug_3821_RegressionS_T.cpp: Bug_3821_Regression.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h Bug_3821_Regression.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
Bug_3821_RegressionC.inl Bug_3821_RegressionS.h Bug_3821_RegressionS_T.h Bug_3821_RegressionC.h Bug_3821_RegressionS.cpp Bug_3821_RegressionC.cpp Bug_3821_RegressionS_T.cpp: $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += fullC.inl fullS.h fullS_T.h fullC.h fullS.cpp fullC.cpp fullS_T.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "full.idl" -nt "fullC.inl" 2> /dev/null || $(TEST_EXE) "full.idl" -nt "fullS.h" 2> /dev/null || $(TEST_EXE) "full.idl" -nt "fullS_T.h" 2> /dev/null || $(TEST_EXE) "full.idl" -nt "fullC.h" 2> /dev/null || $(TEST_EXE) "full.idl" -nt "fullS.cpp" 2> /dev/null || $(TEST_EXE) "full.idl" -nt "fullC.cpp" 2> /dev/null || $(TEST_EXE) "full.idl" -nt "fullS_T.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "fullC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "fullS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "fullS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "fullC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "fullS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "fullC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "fullS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "fullC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "fullS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "fullS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "fullC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "fullS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "fullC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "fullS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "fullC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "fullS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "fullS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "fullC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "fullS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "fullC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "fullS_T.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
fullC.inl fullS.h fullS_T.h fullC.h fullS.cpp fullC.cpp fullS_T.cpp: full.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h full.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
fullC.inl fullS.h fullS_T.h fullC.h fullS.cpp fullC.cpp fullS_T.cpp: $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += fwdC.inl fwdS.h fwdS_T.h fwdC.h fwdS.cpp fwdC.cpp fwdS_T.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "fwd.idl" -nt "fwdC.inl" 2> /dev/null || $(TEST_EXE) "fwd.idl" -nt "fwdS.h" 2> /dev/null || $(TEST_EXE) "fwd.idl" -nt "fwdS_T.h" 2> /dev/null || $(TEST_EXE) "fwd.idl" -nt "fwdC.h" 2> /dev/null || $(TEST_EXE) "fwd.idl" -nt "fwdS.cpp" 2> /dev/null || $(TEST_EXE) "fwd.idl" -nt "fwdC.cpp" 2> /dev/null || $(TEST_EXE) "fwd.idl" -nt "fwdS_T.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "fwdC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "fwdS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "fwdS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "fwdC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "fwdS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "fwdC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "fwdS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "fwdC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "fwdS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "fwdS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "fwdC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "fwdS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "fwdC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "fwdS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "fwdC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "fwdS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "fwdS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "fwdC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "fwdS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "fwdC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "fwdS_T.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
fwdC.inl fwdS.h fwdS_T.h fwdC.h fwdS.cpp fwdC.cpp fwdS_T.cpp: fwd.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h fwd.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
fwdC.inl fwdS.h fwdS_T.h fwdC.h fwdS.cpp fwdC.cpp fwdS_T.cpp: $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += gperfC.inl gperfS.h gperfS_T.h gperfC.h gperfS.cpp gperfC.cpp gperfS_T.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "gperf.idl" -nt "gperfC.inl" 2> /dev/null || $(TEST_EXE) "gperf.idl" -nt "gperfS.h" 2> /dev/null || $(TEST_EXE) "gperf.idl" -nt "gperfS_T.h" 2> /dev/null || $(TEST_EXE) "gperf.idl" -nt "gperfC.h" 2> /dev/null || $(TEST_EXE) "gperf.idl" -nt "gperfS.cpp" 2> /dev/null || $(TEST_EXE) "gperf.idl" -nt "gperfC.cpp" 2> /dev/null || $(TEST_EXE) "gperf.idl" -nt "gperfS_T.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "gperfC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "gperfS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "gperfS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "gperfC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "gperfS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "gperfC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "gperfS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "gperfC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "gperfS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "gperfS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "gperfC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "gperfS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "gperfC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "gperfS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "gperfC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "gperfS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "gperfS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "gperfC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "gperfS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "gperfC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "gperfS_T.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
gperfC.inl gperfS.h gperfS_T.h gperfC.h gperfS.cpp gperfC.cpp gperfS_T.cpp: gperf.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h gperf.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
gperfC.inl gperfS.h gperfS_T.h gperfC.h gperfS.cpp gperfC.cpp gperfS_T.cpp: $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += interfaceC.inl interfaceS.h interfaceS_T.h interfaceC.h interfaceS.cpp interfaceC.cpp interfaceS_T.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "interface.idl" -nt "interfaceC.inl" 2> /dev/null || $(TEST_EXE) "interface.idl" -nt "interfaceS.h" 2> /dev/null || $(TEST_EXE) "interface.idl" -nt "interfaceS_T.h" 2> /dev/null || $(TEST_EXE) "interface.idl" -nt "interfaceC.h" 2> /dev/null || $(TEST_EXE) "interface.idl" -nt "interfaceS.cpp" 2> /dev/null || $(TEST_EXE) "interface.idl" -nt "interfaceC.cpp" 2> /dev/null || $(TEST_EXE) "interface.idl" -nt "interfaceS_T.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "interfaceC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "interfaceS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "interfaceS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "interfaceC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "interfaceS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "interfaceC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "interfaceS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "interfaceC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "interfaceS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "interfaceS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "interfaceC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "interfaceS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "interfaceC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "interfaceS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "interfaceC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "interfaceS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "interfaceS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "interfaceC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "interfaceS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "interfaceC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "interfaceS_T.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
interfaceC.inl interfaceS.h interfaceS_T.h interfaceC.h interfaceS.cpp interfaceC.cpp interfaceS_T.cpp: interface.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h interface.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
interfaceC.inl interfaceS.h interfaceS_T.h interfaceC.h interfaceS.cpp interfaceC.cpp interfaceS_T.cpp: $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += nested_scopeC.inl nested_scopeS.h nested_scopeS_T.h nested_scopeC.h nested_scopeS.cpp nested_scopeC.cpp nested_scopeS_T.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "nested_scope.idl" -nt "nested_scopeC.inl" 2> /dev/null || $(TEST_EXE) "nested_scope.idl" -nt "nested_scopeS.h" 2> /dev/null || $(TEST_EXE) "nested_scope.idl" -nt "nested_scopeS_T.h" 2> /dev/null || $(TEST_EXE) "nested_scope.idl" -nt "nested_scopeC.h" 2> /dev/null || $(TEST_EXE) "nested_scope.idl" -nt "nested_scopeS.cpp" 2> /dev/null || $(TEST_EXE) "nested_scope.idl" -nt "nested_scopeC.cpp" 2> /dev/null || $(TEST_EXE) "nested_scope.idl" -nt "nested_scopeS_T.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "nested_scopeC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "nested_scopeS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "nested_scopeS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "nested_scopeC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "nested_scopeS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "nested_scopeC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "nested_scopeS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "nested_scopeC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "nested_scopeS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "nested_scopeS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "nested_scopeC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "nested_scopeS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "nested_scopeC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "nested_scopeS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "nested_scopeC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "nested_scopeS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "nested_scopeS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "nested_scopeC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "nested_scopeS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "nested_scopeC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "nested_scopeS_T.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
nested_scopeC.inl nested_scopeS.h nested_scopeS_T.h nested_scopeC.h nested_scopeS.cpp nested_scopeC.cpp nested_scopeS_T.cpp: nested_scope.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h nested_scope.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
nested_scopeC.inl nested_scopeS.h nested_scopeS_T.h nested_scopeC.h nested_scopeS.cpp nested_scopeC.cpp nested_scopeS_T.cpp: $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += old_constantsC.inl old_constantsS.h old_constantsS_T.h old_constantsC.h old_constantsS.cpp old_constantsC.cpp old_constantsS_T.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "old_constants.idl" -nt "old_constantsC.inl" 2> /dev/null || $(TEST_EXE) "old_constants.idl" -nt "old_constantsS.h" 2> /dev/null || $(TEST_EXE) "old_constants.idl" -nt "old_constantsS_T.h" 2> /dev/null || $(TEST_EXE) "old_constants.idl" -nt "old_constantsC.h" 2> /dev/null || $(TEST_EXE) "old_constants.idl" -nt "old_constantsS.cpp" 2> /dev/null || $(TEST_EXE) "old_constants.idl" -nt "old_constantsC.cpp" 2> /dev/null || $(TEST_EXE) "old_constants.idl" -nt "old_constantsS_T.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "old_constantsC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "old_constantsS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "old_constantsS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "old_constantsC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "old_constantsS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "old_constantsC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "old_constantsS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "old_constantsC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "old_constantsS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "old_constantsS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "old_constantsC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "old_constantsS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "old_constantsC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "old_constantsS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "old_constantsC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "old_constantsS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "old_constantsS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "old_constantsC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "old_constantsS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "old_constantsC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "old_constantsS_T.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
old_constantsC.inl old_constantsS.h old_constantsS_T.h old_constantsC.h old_constantsS.cpp old_constantsC.cpp old_constantsS_T.cpp: old_constants.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h old_constants.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
old_constantsC.inl old_constantsS.h old_constantsS_T.h old_constantsC.h old_constantsS.cpp old_constantsC.cpp old_constantsS_T.cpp: $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += simpleC.inl simpleS.h simpleS_T.h simpleC.h simpleS.cpp simpleC.cpp simpleS_T.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "simple.idl" -nt "simpleC.inl" 2> /dev/null || $(TEST_EXE) "simple.idl" -nt "simpleS.h" 2> /dev/null || $(TEST_EXE) "simple.idl" -nt "simpleS_T.h" 2> /dev/null || $(TEST_EXE) "simple.idl" -nt "simpleC.h" 2> /dev/null || $(TEST_EXE) "simple.idl" -nt "simpleS.cpp" 2> /dev/null || $(TEST_EXE) "simple.idl" -nt "simpleC.cpp" 2> /dev/null || $(TEST_EXE) "simple.idl" -nt "simpleS_T.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "simpleC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "simpleS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "simpleS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "simpleC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "simpleS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "simpleC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "simpleS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "simpleC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "simpleS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "simpleS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "simpleC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "simpleS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "simpleC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "simpleS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "simpleC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "simpleS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "simpleS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "simpleC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "simpleS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "simpleC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "simpleS_T.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
simpleC.inl simpleS.h simpleS_T.h simpleC.h simpleS.cpp simpleC.cpp simpleS_T.cpp: simple.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h simple.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
simpleC.inl simpleS.h simpleS_T.h simpleC.h simpleS.cpp simpleC.cpp simpleS_T.cpp: $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += simple2C.inl simple2S.h simple2S_T.h simple2C.h simple2S.cpp simple2C.cpp simple2S_T.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "simple2.idl" -nt "simple2C.inl" 2> /dev/null || $(TEST_EXE) "simple2.idl" -nt "simple2S.h" 2> /dev/null || $(TEST_EXE) "simple2.idl" -nt "simple2S_T.h" 2> /dev/null || $(TEST_EXE) "simple2.idl" -nt "simple2C.h" 2> /dev/null || $(TEST_EXE) "simple2.idl" -nt "simple2S.cpp" 2> /dev/null || $(TEST_EXE) "simple2.idl" -nt "simple2C.cpp" 2> /dev/null || $(TEST_EXE) "simple2.idl" -nt "simple2S_T.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "simple2C.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "simple2S.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "simple2S_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "simple2C.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "simple2S.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "simple2C.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "simple2S_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "simple2C.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "simple2S.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "simple2S_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "simple2C.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "simple2S.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "simple2C.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "simple2S_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "simple2C.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "simple2S.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "simple2S_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "simple2C.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "simple2S.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "simple2C.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "simple2S_T.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
simple2C.inl simple2S.h simple2S_T.h simple2C.h simple2S.cpp simple2C.cpp simple2S_T.cpp: simple2.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h simple2.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
simple2C.inl simple2S.h simple2S_T.h simple2C.h simple2S.cpp simple2C.cpp simple2S_T.cpp: $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += old_arrayC.inl old_arrayS.h old_arrayS_T.h old_arrayC.h old_arrayS.cpp old_arrayC.cpp old_arrayS_T.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "old_array.idl" -nt "old_arrayC.inl" 2> /dev/null || $(TEST_EXE) "old_array.idl" -nt "old_arrayS.h" 2> /dev/null || $(TEST_EXE) "old_array.idl" -nt "old_arrayS_T.h" 2> /dev/null || $(TEST_EXE) "old_array.idl" -nt "old_arrayC.h" 2> /dev/null || $(TEST_EXE) "old_array.idl" -nt "old_arrayS.cpp" 2> /dev/null || $(TEST_EXE) "old_array.idl" -nt "old_arrayC.cpp" 2> /dev/null || $(TEST_EXE) "old_array.idl" -nt "old_arrayS_T.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "old_arrayC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "old_arrayS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "old_arrayS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "old_arrayC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "old_arrayS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "old_arrayC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "old_arrayS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "old_arrayC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "old_arrayS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "old_arrayS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "old_arrayC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "old_arrayS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "old_arrayC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "old_arrayS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "old_arrayC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "old_arrayS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "old_arrayS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "old_arrayC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "old_arrayS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "old_arrayC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "old_arrayS_T.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
old_arrayC.inl old_arrayS.h old_arrayS_T.h old_arrayC.h old_arrayS.cpp old_arrayC.cpp old_arrayS_T.cpp: old_array.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h old_array.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
old_arrayC.inl old_arrayS.h old_arrayS_T.h old_arrayC.h old_arrayS.cpp old_arrayC.cpp old_arrayS_T.cpp: $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += old_sequenceC.inl old_sequenceS.h old_sequenceS_T.h old_sequenceC.h old_sequenceS.cpp old_sequenceC.cpp old_sequenceS_T.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "old_sequence.idl" -nt "old_sequenceC.inl" 2> /dev/null || $(TEST_EXE) "old_sequence.idl" -nt "old_sequenceS.h" 2> /dev/null || $(TEST_EXE) "old_sequence.idl" -nt "old_sequenceS_T.h" 2> /dev/null || $(TEST_EXE) "old_sequence.idl" -nt "old_sequenceC.h" 2> /dev/null || $(TEST_EXE) "old_sequence.idl" -nt "old_sequenceS.cpp" 2> /dev/null || $(TEST_EXE) "old_sequence.idl" -nt "old_sequenceC.cpp" 2> /dev/null || $(TEST_EXE) "old_sequence.idl" -nt "old_sequenceS_T.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "old_sequenceC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "old_sequenceS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "old_sequenceS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "old_sequenceC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "old_sequenceS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "old_sequenceC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "old_sequenceS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "old_sequenceC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "old_sequenceS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "old_sequenceS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "old_sequenceC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "old_sequenceS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "old_sequenceC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "old_sequenceS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "old_sequenceC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "old_sequenceS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "old_sequenceS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "old_sequenceC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "old_sequenceS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "old_sequenceC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "old_sequenceS_T.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
old_sequenceC.inl old_sequenceS.h old_sequenceS_T.h old_sequenceC.h old_sequenceS.cpp old_sequenceC.cpp old_sequenceS_T.cpp: old_sequence.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h old_sequence.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
old_sequenceC.inl old_sequenceS.h old_sequenceS_T.h old_sequenceC.h old_sequenceS.cpp old_sequenceC.cpp old_sequenceS_T.cpp: $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += old_structC.inl old_structS.h old_structS_T.h old_structC.h old_structS.cpp old_structC.cpp old_structS_T.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "old_struct.idl" -nt "old_structC.inl" 2> /dev/null || $(TEST_EXE) "old_struct.idl" -nt "old_structS.h" 2> /dev/null || $(TEST_EXE) "old_struct.idl" -nt "old_structS_T.h" 2> /dev/null || $(TEST_EXE) "old_struct.idl" -nt "old_structC.h" 2> /dev/null || $(TEST_EXE) "old_struct.idl" -nt "old_structS.cpp" 2> /dev/null || $(TEST_EXE) "old_struct.idl" -nt "old_structC.cpp" 2> /dev/null || $(TEST_EXE) "old_struct.idl" -nt "old_structS_T.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "old_structC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "old_structS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "old_structS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "old_structC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "old_structS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "old_structC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "old_structS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "old_structC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "old_structS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "old_structS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "old_structC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "old_structS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "old_structC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "old_structS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "old_structC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "old_structS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "old_structS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "old_structC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "old_structS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "old_structC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "old_structS_T.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
old_structC.inl old_structS.h old_structS_T.h old_structC.h old_structS.cpp old_structC.cpp old_structS_T.cpp: old_struct.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h old_struct.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
old_structC.inl old_structS.h old_structS_T.h old_structC.h old_structS.cpp old_structC.cpp old_structS_T.cpp: $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += old_unionC.inl old_unionS.h old_unionS_T.h old_unionC.h old_unionS.cpp old_unionC.cpp old_unionS_T.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "old_union.idl" -nt "old_unionC.inl" 2> /dev/null || $(TEST_EXE) "old_union.idl" -nt "old_unionS.h" 2> /dev/null || $(TEST_EXE) "old_union.idl" -nt "old_unionS_T.h" 2> /dev/null || $(TEST_EXE) "old_union.idl" -nt "old_unionC.h" 2> /dev/null || $(TEST_EXE) "old_union.idl" -nt "old_unionS.cpp" 2> /dev/null || $(TEST_EXE) "old_union.idl" -nt "old_unionC.cpp" 2> /dev/null || $(TEST_EXE) "old_union.idl" -nt "old_unionS_T.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "old_unionC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "old_unionS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "old_unionS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "old_unionC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "old_unionS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "old_unionC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "old_unionS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "old_unionC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "old_unionS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "old_unionS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "old_unionC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "old_unionS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "old_unionC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "old_unionS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "old_unionC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "old_unionS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "old_unionS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "old_unionC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "old_unionS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "old_unionC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "old_unionS_T.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
old_unionC.inl old_unionS.h old_unionS_T.h old_unionC.h old_unionS.cpp old_unionC.cpp old_unionS_T.cpp: old_union.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h old_union.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
old_unionC.inl old_unionS.h old_unionS_T.h old_unionC.h old_unionS.cpp old_unionC.cpp old_unionS_T.cpp: $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += old_union2C.inl old_union2S.h old_union2S_T.h old_union2C.h old_union2S.cpp old_union2C.cpp old_union2S_T.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "old_union2.idl" -nt "old_union2C.inl" 2> /dev/null || $(TEST_EXE) "old_union2.idl" -nt "old_union2S.h" 2> /dev/null || $(TEST_EXE) "old_union2.idl" -nt "old_union2S_T.h" 2> /dev/null || $(TEST_EXE) "old_union2.idl" -nt "old_union2C.h" 2> /dev/null || $(TEST_EXE) "old_union2.idl" -nt "old_union2S.cpp" 2> /dev/null || $(TEST_EXE) "old_union2.idl" -nt "old_union2C.cpp" 2> /dev/null || $(TEST_EXE) "old_union2.idl" -nt "old_union2S_T.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "old_union2C.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "old_union2S.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "old_union2S_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "old_union2C.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "old_union2S.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "old_union2C.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "old_union2S_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "old_union2C.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "old_union2S.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "old_union2S_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "old_union2C.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "old_union2S.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "old_union2C.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "old_union2S_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "old_union2C.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "old_union2S.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "old_union2S_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "old_union2C.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "old_union2S.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "old_union2C.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "old_union2S_T.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
old_union2C.inl old_union2S.h old_union2S_T.h old_union2C.h old_union2S.cpp old_union2C.cpp old_union2S_T.cpp: old_union2.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h old_union2.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
old_union2C.inl old_union2S.h old_union2S_T.h old_union2C.h old_union2S.cpp old_union2C.cpp old_union2S_T.cpp: $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += paramsC.inl paramsS.h paramsS_T.h paramsC.h paramsS.cpp paramsC.cpp paramsS_T.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "params.idl" -nt "paramsC.inl" 2> /dev/null || $(TEST_EXE) "params.idl" -nt "paramsS.h" 2> /dev/null || $(TEST_EXE) "params.idl" -nt "paramsS_T.h" 2> /dev/null || $(TEST_EXE) "params.idl" -nt "paramsC.h" 2> /dev/null || $(TEST_EXE) "params.idl" -nt "paramsS.cpp" 2> /dev/null || $(TEST_EXE) "params.idl" -nt "paramsC.cpp" 2> /dev/null || $(TEST_EXE) "params.idl" -nt "paramsS_T.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "paramsC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "paramsS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "paramsS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "paramsC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "paramsS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "paramsC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "paramsS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "paramsC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "paramsS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "paramsS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "paramsC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "paramsS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "paramsC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "paramsS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "paramsC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "paramsS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "paramsS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "paramsC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "paramsS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "paramsC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "paramsS_T.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
paramsC.inl paramsS.h paramsS_T.h paramsC.h paramsS.cpp paramsC.cpp paramsS_T.cpp: params.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h params.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
paramsC.inl paramsS.h paramsS_T.h paramsC.h paramsS.cpp paramsC.cpp paramsS_T.cpp: $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += reopened_modulesC.inl reopened_modulesS.h reopened_modulesS_T.h reopened_modulesC.h reopened_modulesS.cpp reopened_modulesC.cpp reopened_modulesS_T.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "reopened_modules.idl" -nt "reopened_modulesC.inl" 2> /dev/null || $(TEST_EXE) "reopened_modules.idl" -nt "reopened_modulesS.h" 2> /dev/null || $(TEST_EXE) "reopened_modules.idl" -nt "reopened_modulesS_T.h" 2> /dev/null || $(TEST_EXE) "reopened_modules.idl" -nt "reopened_modulesC.h" 2> /dev/null || $(TEST_EXE) "reopened_modules.idl" -nt "reopened_modulesS.cpp" 2> /dev/null || $(TEST_EXE) "reopened_modules.idl" -nt "reopened_modulesC.cpp" 2> /dev/null || $(TEST_EXE) "reopened_modules.idl" -nt "reopened_modulesS_T.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "reopened_modulesC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "reopened_modulesS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "reopened_modulesS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "reopened_modulesC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "reopened_modulesS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "reopened_modulesC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "reopened_modulesS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "reopened_modulesC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "reopened_modulesS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "reopened_modulesS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "reopened_modulesC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "reopened_modulesS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "reopened_modulesC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "reopened_modulesS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "reopened_modulesC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "reopened_modulesS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "reopened_modulesS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "reopened_modulesC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "reopened_modulesS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "reopened_modulesC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "reopened_modulesS_T.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
reopened_modulesC.inl reopened_modulesS.h reopened_modulesS_T.h reopened_modulesC.h reopened_modulesS.cpp reopened_modulesC.cpp reopened_modulesS_T.cpp: reopened_modules.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h reopened_modules.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
reopened_modulesC.inl reopened_modulesS.h reopened_modulesS_T.h reopened_modulesC.h reopened_modulesS.cpp reopened_modulesC.cpp reopened_modulesS_T.cpp: $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += structC.inl structS.h structS_T.h structC.h structS.cpp structC.cpp structS_T.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "struct.idl" -nt "structC.inl" 2> /dev/null || $(TEST_EXE) "struct.idl" -nt "structS.h" 2> /dev/null || $(TEST_EXE) "struct.idl" -nt "structS_T.h" 2> /dev/null || $(TEST_EXE) "struct.idl" -nt "structC.h" 2> /dev/null || $(TEST_EXE) "struct.idl" -nt "structS.cpp" 2> /dev/null || $(TEST_EXE) "struct.idl" -nt "structC.cpp" 2> /dev/null || $(TEST_EXE) "struct.idl" -nt "structS_T.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "structC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "structS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "structS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "structC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "structS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "structC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "structS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "structC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "structS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "structS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "structC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "structS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "structC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "structS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "structC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "structS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "structS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "structC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "structS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "structC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "structS_T.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
structC.inl structS.h structS_T.h structC.h structS.cpp structC.cpp structS_T.cpp: struct.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h struct.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
structC.inl structS.h structS_T.h structC.h structS.cpp structC.cpp structS_T.cpp: $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += reopen_include1C.inl reopen_include1S.h reopen_include1S_T.h reopen_include1C.h reopen_include1S.cpp reopen_include1C.cpp reopen_include1S_T.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "reopen_include1.idl" -nt "reopen_include1C.inl" 2> /dev/null || $(TEST_EXE) "reopen_include1.idl" -nt "reopen_include1S.h" 2> /dev/null || $(TEST_EXE) "reopen_include1.idl" -nt "reopen_include1S_T.h" 2> /dev/null || $(TEST_EXE) "reopen_include1.idl" -nt "reopen_include1C.h" 2> /dev/null || $(TEST_EXE) "reopen_include1.idl" -nt "reopen_include1S.cpp" 2> /dev/null || $(TEST_EXE) "reopen_include1.idl" -nt "reopen_include1C.cpp" 2> /dev/null || $(TEST_EXE) "reopen_include1.idl" -nt "reopen_include1S_T.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "reopen_include1C.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "reopen_include1S.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "reopen_include1S_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "reopen_include1C.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "reopen_include1S.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "reopen_include1C.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "reopen_include1S_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "reopen_include1C.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "reopen_include1S.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "reopen_include1S_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "reopen_include1C.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "reopen_include1S.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "reopen_include1C.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "reopen_include1S_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "reopen_include1C.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "reopen_include1S.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "reopen_include1S_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "reopen_include1C.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "reopen_include1S.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "reopen_include1C.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "reopen_include1S_T.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
reopen_include1C.inl reopen_include1S.h reopen_include1S_T.h reopen_include1C.h reopen_include1S.cpp reopen_include1C.cpp reopen_include1S_T.cpp: reopen_include1.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h reopen_include1.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
reopen_include1C.inl reopen_include1S.h reopen_include1S_T.h reopen_include1C.h reopen_include1S.cpp reopen_include1C.cpp reopen_include1S_T.cpp: $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += reopen_include2C.inl reopen_include2S.h reopen_include2S_T.h reopen_include2C.h reopen_include2S.cpp reopen_include2C.cpp reopen_include2S_T.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "reopen_include2.idl" -nt "reopen_include2C.inl" 2> /dev/null || $(TEST_EXE) "reopen_include2.idl" -nt "reopen_include2S.h" 2> /dev/null || $(TEST_EXE) "reopen_include2.idl" -nt "reopen_include2S_T.h" 2> /dev/null || $(TEST_EXE) "reopen_include2.idl" -nt "reopen_include2C.h" 2> /dev/null || $(TEST_EXE) "reopen_include2.idl" -nt "reopen_include2S.cpp" 2> /dev/null || $(TEST_EXE) "reopen_include2.idl" -nt "reopen_include2C.cpp" 2> /dev/null || $(TEST_EXE) "reopen_include2.idl" -nt "reopen_include2S_T.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "reopen_include2C.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "reopen_include2S.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "reopen_include2S_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "reopen_include2C.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "reopen_include2S.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "reopen_include2C.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "reopen_include2S_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "reopen_include2C.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "reopen_include2S.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "reopen_include2S_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "reopen_include2C.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "reopen_include2S.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "reopen_include2C.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "reopen_include2S_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "reopen_include2C.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "reopen_include2S.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "reopen_include2S_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "reopen_include2C.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "reopen_include2S.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "reopen_include2C.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "reopen_include2S_T.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
reopen_include2C.inl reopen_include2S.h reopen_include2S_T.h reopen_include2C.h reopen_include2S.cpp reopen_include2C.cpp reopen_include2S_T.cpp: reopen_include2.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h reopen_include2.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
reopen_include2C.inl reopen_include2S.h reopen_include2S_T.h reopen_include2C.h reopen_include2S.cpp reopen_include2C.cpp reopen_include2S_T.cpp: $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += typeprefixC.inl typeprefixS.h typeprefixS_T.h typeprefixC.h typeprefixS.cpp typeprefixC.cpp typeprefixS_T.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "typeprefix.idl" -nt "typeprefixC.inl" 2> /dev/null || $(TEST_EXE) "typeprefix.idl" -nt "typeprefixS.h" 2> /dev/null || $(TEST_EXE) "typeprefix.idl" -nt "typeprefixS_T.h" 2> /dev/null || $(TEST_EXE) "typeprefix.idl" -nt "typeprefixC.h" 2> /dev/null || $(TEST_EXE) "typeprefix.idl" -nt "typeprefixS.cpp" 2> /dev/null || $(TEST_EXE) "typeprefix.idl" -nt "typeprefixC.cpp" 2> /dev/null || $(TEST_EXE) "typeprefix.idl" -nt "typeprefixS_T.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "typeprefixC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "typeprefixS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "typeprefixS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "typeprefixC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "typeprefixS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "typeprefixC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "typeprefixS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "typeprefixC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "typeprefixS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "typeprefixS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "typeprefixC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "typeprefixS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "typeprefixC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "typeprefixS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "typeprefixC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "typeprefixS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "typeprefixS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "typeprefixC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "typeprefixS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "typeprefixC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "typeprefixS_T.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
typeprefixC.inl typeprefixS.h typeprefixS_T.h typeprefixC.h typeprefixS.cpp typeprefixC.cpp typeprefixS_T.cpp: typeprefix.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h typeprefix.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
typeprefixC.inl typeprefixS.h typeprefixS_T.h typeprefixC.h typeprefixS.cpp typeprefixC.cpp typeprefixS_T.cpp: $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += enum_in_structC.inl enum_in_structS.h enum_in_structS_T.h enum_in_structC.h enum_in_structS.cpp enum_in_structC.cpp enum_in_structS_T.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "enum_in_struct.idl" -nt "enum_in_structC.inl" 2> /dev/null || $(TEST_EXE) "enum_in_struct.idl" -nt "enum_in_structS.h" 2> /dev/null || $(TEST_EXE) "enum_in_struct.idl" -nt "enum_in_structS_T.h" 2> /dev/null || $(TEST_EXE) "enum_in_struct.idl" -nt "enum_in_structC.h" 2> /dev/null || $(TEST_EXE) "enum_in_struct.idl" -nt "enum_in_structS.cpp" 2> /dev/null || $(TEST_EXE) "enum_in_struct.idl" -nt "enum_in_structC.cpp" 2> /dev/null || $(TEST_EXE) "enum_in_struct.idl" -nt "enum_in_structS_T.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "enum_in_structC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "enum_in_structS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "enum_in_structS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "enum_in_structC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "enum_in_structS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "enum_in_structC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "enum_in_structS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "enum_in_structC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "enum_in_structS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "enum_in_structS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "enum_in_structC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "enum_in_structS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "enum_in_structC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "enum_in_structS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "enum_in_structC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "enum_in_structS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "enum_in_structS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "enum_in_structC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "enum_in_structS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "enum_in_structC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "enum_in_structS_T.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
enum_in_structC.inl enum_in_structS.h enum_in_structS_T.h enum_in_structC.h enum_in_structS.cpp enum_in_structC.cpp enum_in_structS_T.cpp: enum_in_struct.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -as enum_in_struct.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
enum_in_structC.inl enum_in_structS.h enum_in_structS_T.h enum_in_structC.h enum_in_structS.cpp enum_in_structC.cpp enum_in_structS_T.cpp: $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += arrayC.inl arrayS.h arrayS_T.h arrayC.h arrayS.cpp arrayC.cpp arrayS_T.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "array.idl" -nt "arrayC.inl" 2> /dev/null || $(TEST_EXE) "array.idl" -nt "arrayS.h" 2> /dev/null || $(TEST_EXE) "array.idl" -nt "arrayS_T.h" 2> /dev/null || $(TEST_EXE) "array.idl" -nt "arrayC.h" 2> /dev/null || $(TEST_EXE) "array.idl" -nt "arrayS.cpp" 2> /dev/null || $(TEST_EXE) "array.idl" -nt "arrayC.cpp" 2> /dev/null || $(TEST_EXE) "array.idl" -nt "arrayS_T.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "arrayC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "arrayS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "arrayS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "arrayC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "arrayS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "arrayC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "arrayS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "arrayC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "arrayS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "arrayS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "arrayC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "arrayS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "arrayC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "arrayS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "arrayC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "arrayS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "arrayS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "arrayC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "arrayS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "arrayC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "arrayS_T.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
arrayC.inl arrayS.h arrayS_T.h arrayC.h arrayS.cpp arrayC.cpp arrayS_T.cpp: array.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -as array.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
arrayC.inl arrayS.h arrayS_T.h arrayC.h arrayS.cpp arrayC.cpp arrayS_T.cpp: $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += array_anon_nestedC.inl array_anon_nestedS.h array_anon_nestedS_T.h array_anon_nestedC.h array_anon_nestedS.cpp array_anon_nestedC.cpp array_anon_nestedS_T.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "array_anon_nested.idl" -nt "array_anon_nestedC.inl" 2> /dev/null || $(TEST_EXE) "array_anon_nested.idl" -nt "array_anon_nestedS.h" 2> /dev/null || $(TEST_EXE) "array_anon_nested.idl" -nt "array_anon_nestedS_T.h" 2> /dev/null || $(TEST_EXE) "array_anon_nested.idl" -nt "array_anon_nestedC.h" 2> /dev/null || $(TEST_EXE) "array_anon_nested.idl" -nt "array_anon_nestedS.cpp" 2> /dev/null || $(TEST_EXE) "array_anon_nested.idl" -nt "array_anon_nestedC.cpp" 2> /dev/null || $(TEST_EXE) "array_anon_nested.idl" -nt "array_anon_nestedS_T.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "array_anon_nestedC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "array_anon_nestedS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "array_anon_nestedS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "array_anon_nestedC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "array_anon_nestedS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "array_anon_nestedC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "array_anon_nestedS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "array_anon_nestedC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "array_anon_nestedS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "array_anon_nestedS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "array_anon_nestedC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "array_anon_nestedS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "array_anon_nestedC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "array_anon_nestedS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "array_anon_nestedC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "array_anon_nestedS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "array_anon_nestedS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "array_anon_nestedC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "array_anon_nestedS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "array_anon_nestedC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "array_anon_nestedS_T.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
array_anon_nestedC.inl array_anon_nestedS.h array_anon_nestedS_T.h array_anon_nestedC.h array_anon_nestedS.cpp array_anon_nestedC.cpp array_anon_nestedS_T.cpp: array_anon_nested.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -as array_anon_nested.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
array_anon_nestedC.inl array_anon_nestedS.h array_anon_nestedS_T.h array_anon_nestedC.h array_anon_nestedS.cpp array_anon_nestedC.cpp array_anon_nestedS_T.cpp: $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += includedC.inl includedS.h includedS_T.h includedC.h includedS.cpp includedC.cpp includedS_T.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "included.idl" -nt "includedC.inl" 2> /dev/null || $(TEST_EXE) "included.idl" -nt "includedS.h" 2> /dev/null || $(TEST_EXE) "included.idl" -nt "includedS_T.h" 2> /dev/null || $(TEST_EXE) "included.idl" -nt "includedC.h" 2> /dev/null || $(TEST_EXE) "included.idl" -nt "includedS.cpp" 2> /dev/null || $(TEST_EXE) "included.idl" -nt "includedC.cpp" 2> /dev/null || $(TEST_EXE) "included.idl" -nt "includedS_T.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "includedC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "includedS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "includedS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "includedC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "includedS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "includedC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "includedS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "includedC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "includedS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "includedS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "includedC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "includedS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "includedC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "includedS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "includedC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "includedS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "includedS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "includedC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "includedS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "includedC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "includedS_T.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
includedC.inl includedS.h includedS_T.h includedC.h includedS.cpp includedC.cpp includedS_T.cpp: included.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -as included.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
includedC.inl includedS.h includedS_T.h includedC.h includedS.cpp includedC.cpp includedS_T.cpp: $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += includingC.inl includingS.h includingS_T.h includingC.h includingS.cpp includingC.cpp includingS_T.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "including.idl" -nt "includingC.inl" 2> /dev/null || $(TEST_EXE) "including.idl" -nt "includingS.h" 2> /dev/null || $(TEST_EXE) "including.idl" -nt "includingS_T.h" 2> /dev/null || $(TEST_EXE) "including.idl" -nt "includingC.h" 2> /dev/null || $(TEST_EXE) "including.idl" -nt "includingS.cpp" 2> /dev/null || $(TEST_EXE) "including.idl" -nt "includingC.cpp" 2> /dev/null || $(TEST_EXE) "including.idl" -nt "includingS_T.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "includingC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "includingS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "includingS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "includingC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "includingS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "includingC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "includingS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "includingC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "includingS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "includingS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "includingC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "includingS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "includingC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "includingS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "includingC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "includingS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "includingS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "includingC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "includingS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "includingC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "includingS_T.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
includingC.inl includingS.h includingS_T.h includingC.h includingS.cpp includingC.cpp includingS_T.cpp: including.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -as including.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
includingC.inl includingS.h includingS_T.h includingC.h includingS.cpp includingC.cpp includingS_T.cpp: $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += sequenceC.inl sequenceS.h sequenceS_T.h sequenceC.h sequenceS.cpp sequenceC.cpp sequenceS_T.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "sequence.idl" -nt "sequenceC.inl" 2> /dev/null || $(TEST_EXE) "sequence.idl" -nt "sequenceS.h" 2> /dev/null || $(TEST_EXE) "sequence.idl" -nt "sequenceS_T.h" 2> /dev/null || $(TEST_EXE) "sequence.idl" -nt "sequenceC.h" 2> /dev/null || $(TEST_EXE) "sequence.idl" -nt "sequenceS.cpp" 2> /dev/null || $(TEST_EXE) "sequence.idl" -nt "sequenceC.cpp" 2> /dev/null || $(TEST_EXE) "sequence.idl" -nt "sequenceS_T.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "sequenceC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "sequenceS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "sequenceS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "sequenceC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "sequenceS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "sequenceC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "sequenceS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "sequenceC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "sequenceS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "sequenceS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "sequenceC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "sequenceS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "sequenceC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "sequenceS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "sequenceC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "sequenceS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "sequenceS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "sequenceC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "sequenceS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "sequenceC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "sequenceS_T.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
sequenceC.inl sequenceS.h sequenceS_T.h sequenceC.h sequenceS.cpp sequenceC.cpp sequenceS_T.cpp: sequence.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -as sequence.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
sequenceC.inl sequenceS.h sequenceS_T.h sequenceC.h sequenceS.cpp sequenceC.cpp sequenceS_T.cpp: $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += unionC.inl unionS.h unionS_T.h unionC.h unionS.cpp unionC.cpp unionS_T.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "union.idl" -nt "unionC.inl" 2> /dev/null || $(TEST_EXE) "union.idl" -nt "unionS.h" 2> /dev/null || $(TEST_EXE) "union.idl" -nt "unionS_T.h" 2> /dev/null || $(TEST_EXE) "union.idl" -nt "unionC.h" 2> /dev/null || $(TEST_EXE) "union.idl" -nt "unionS.cpp" 2> /dev/null || $(TEST_EXE) "union.idl" -nt "unionC.cpp" 2> /dev/null || $(TEST_EXE) "union.idl" -nt "unionS_T.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "unionC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "unionS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "unionS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "unionC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "unionS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "unionC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "unionS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "unionC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "unionS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "unionS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "unionC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "unionS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "unionC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "unionS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "unionC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "unionS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "unionS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "unionC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "unionS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "unionC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "unionS_T.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
unionC.inl unionS.h unionS_T.h unionC.h unionS.cpp unionC.cpp unionS_T.cpp: union.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -as union.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
unionC.inl unionS.h unionS_T.h unionC.h unionS.cpp unionC.cpp unionS_T.cpp: $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += anyunionC.inl anyunionS.h anyunionS_T.h anyunionC.h anyunionS.cpp anyunionC.cpp anyunionS_T.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "anyunion.idl" -nt "anyunionC.inl" 2> /dev/null || $(TEST_EXE) "anyunion.idl" -nt "anyunionS.h" 2> /dev/null || $(TEST_EXE) "anyunion.idl" -nt "anyunionS_T.h" 2> /dev/null || $(TEST_EXE) "anyunion.idl" -nt "anyunionC.h" 2> /dev/null || $(TEST_EXE) "anyunion.idl" -nt "anyunionS.cpp" 2> /dev/null || $(TEST_EXE) "anyunion.idl" -nt "anyunionC.cpp" 2> /dev/null || $(TEST_EXE) "anyunion.idl" -nt "anyunionS_T.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "anyunionC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "anyunionS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "anyunionS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "anyunionC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "anyunionS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "anyunionC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "anyunionS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "anyunionC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "anyunionS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "anyunionS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "anyunionC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "anyunionS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "anyunionC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "anyunionS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "anyunionC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "anyunionS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "anyunionS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "anyunionC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "anyunionS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "anyunionC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "anyunionS_T.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
anyunionC.inl anyunionS.h anyunionS_T.h anyunionC.h anyunionS.cpp anyunionC.cpp anyunionS_T.cpp: anyunion.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -as anyunion.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
anyunionC.inl anyunionS.h anyunionS_T.h anyunionC.h anyunionS.cpp anyunionC.cpp anyunionS_T.cpp: $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += valuetypeC.inl valuetypeS.h valuetypeS_T.h valuetypeC.h valuetypeS.cpp valuetypeC.cpp valuetypeS_T.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "valuetype.idl" -nt "valuetypeC.inl" 2> /dev/null || $(TEST_EXE) "valuetype.idl" -nt "valuetypeS.h" 2> /dev/null || $(TEST_EXE) "valuetype.idl" -nt "valuetypeS_T.h" 2> /dev/null || $(TEST_EXE) "valuetype.idl" -nt "valuetypeC.h" 2> /dev/null || $(TEST_EXE) "valuetype.idl" -nt "valuetypeS.cpp" 2> /dev/null || $(TEST_EXE) "valuetype.idl" -nt "valuetypeC.cpp" 2> /dev/null || $(TEST_EXE) "valuetype.idl" -nt "valuetypeS_T.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "valuetypeC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "valuetypeS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "valuetypeS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "valuetypeC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "valuetypeS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "valuetypeC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "valuetypeS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "valuetypeC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "valuetypeS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "valuetypeS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "valuetypeC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "valuetypeS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "valuetypeC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "valuetypeS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "valuetypeC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "valuetypeS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "valuetypeS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "valuetypeC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "valuetypeS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "valuetypeC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "valuetypeS_T.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
valuetypeC.inl valuetypeS.h valuetypeS_T.h valuetypeC.h valuetypeS.cpp valuetypeC.cpp valuetypeS_T.cpp: valuetype.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -as valuetype.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
valuetypeC.inl valuetypeS.h valuetypeS_T.h valuetypeC.h valuetypeS.cpp valuetypeC.cpp valuetypeS_T.cpp: $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += anonymousC.inl anonymousS.h anonymousA.h anonymousS_T.h anonymousC.h anonymousS.cpp anonymousC.cpp anonymousA.cpp anonymousS_T.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "anonymous.idl" -nt "anonymousC.inl" 2> /dev/null || $(TEST_EXE) "anonymous.idl" -nt "anonymousS.h" 2> /dev/null || $(TEST_EXE) "anonymous.idl" -nt "anonymousA.h" 2> /dev/null || $(TEST_EXE) "anonymous.idl" -nt "anonymousS_T.h" 2> /dev/null || $(TEST_EXE) "anonymous.idl" -nt "anonymousC.h" 2> /dev/null || $(TEST_EXE) "anonymous.idl" -nt "anonymousS.cpp" 2> /dev/null || $(TEST_EXE) "anonymous.idl" -nt "anonymousC.cpp" 2> /dev/null || $(TEST_EXE) "anonymous.idl" -nt "anonymousA.cpp" 2> /dev/null || $(TEST_EXE) "anonymous.idl" -nt "anonymousS_T.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "anonymousC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "anonymousS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "anonymousA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "anonymousS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "anonymousC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "anonymousS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "anonymousC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "anonymousA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "anonymousS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "anonymousC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "anonymousS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "anonymousA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "anonymousS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "anonymousC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "anonymousS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "anonymousC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "anonymousA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "anonymousS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "anonymousC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "anonymousS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "anonymousA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "anonymousS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "anonymousC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "anonymousS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "anonymousC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "anonymousA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "anonymousS_T.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
anonymousC.inl anonymousS.h anonymousA.h anonymousS_T.h anonymousC.h anonymousS.cpp anonymousC.cpp anonymousA.cpp anonymousS_T.cpp: anonymous.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -GA -as anonymous.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
anonymousC.inl anonymousS.h anonymousA.h anonymousS_T.h anonymousC.h anonymousS.cpp anonymousC.cpp anonymousA.cpp anonymousS_T.cpp: $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += dif2C.inl dif2S.h dif2A.h dif2S_T.h dif2C.h dif2S.cpp dif2C.cpp dif2A.cpp dif2S_T.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "dif2.idl" -nt "dif2C.inl" 2> /dev/null || $(TEST_EXE) "dif2.idl" -nt "dif2S.h" 2> /dev/null || $(TEST_EXE) "dif2.idl" -nt "dif2A.h" 2> /dev/null || $(TEST_EXE) "dif2.idl" -nt "dif2S_T.h" 2> /dev/null || $(TEST_EXE) "dif2.idl" -nt "dif2C.h" 2> /dev/null || $(TEST_EXE) "dif2.idl" -nt "dif2S.cpp" 2> /dev/null || $(TEST_EXE) "dif2.idl" -nt "dif2C.cpp" 2> /dev/null || $(TEST_EXE) "dif2.idl" -nt "dif2A.cpp" 2> /dev/null || $(TEST_EXE) "dif2.idl" -nt "dif2S_T.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "dif2C.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "dif2S.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "dif2A.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "dif2S_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "dif2C.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "dif2S.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "dif2C.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "dif2A.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "dif2S_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "dif2C.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "dif2S.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "dif2A.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "dif2S_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "dif2C.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "dif2S.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "dif2C.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "dif2A.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "dif2S_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "dif2C.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "dif2S.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "dif2A.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "dif2S_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "dif2C.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "dif2S.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "dif2C.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "dif2A.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "dif2S_T.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
dif2C.inl dif2S.h dif2A.h dif2S_T.h dif2C.h dif2S.cpp dif2C.cpp dif2A.cpp dif2S_T.cpp: dif2.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -GA -as dif2.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
dif2C.inl dif2S.h dif2A.h dif2S_T.h dif2C.h dif2S.cpp dif2C.cpp dif2A.cpp dif2S_T.cpp: $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += array_onlyC.inl array_onlyS.h array_onlyA.h array_onlyS_T.h array_onlyC.h array_onlyS.cpp array_onlyC.cpp array_onlyA.cpp array_onlyS_T.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "array_only.idl" -nt "array_onlyC.inl" 2> /dev/null || $(TEST_EXE) "array_only.idl" -nt "array_onlyS.h" 2> /dev/null || $(TEST_EXE) "array_only.idl" -nt "array_onlyA.h" 2> /dev/null || $(TEST_EXE) "array_only.idl" -nt "array_onlyS_T.h" 2> /dev/null || $(TEST_EXE) "array_only.idl" -nt "array_onlyC.h" 2> /dev/null || $(TEST_EXE) "array_only.idl" -nt "array_onlyS.cpp" 2> /dev/null || $(TEST_EXE) "array_only.idl" -nt "array_onlyC.cpp" 2> /dev/null || $(TEST_EXE) "array_only.idl" -nt "array_onlyA.cpp" 2> /dev/null || $(TEST_EXE) "array_only.idl" -nt "array_onlyS_T.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "array_onlyC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "array_onlyS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "array_onlyA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "array_onlyS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "array_onlyC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "array_onlyS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "array_onlyC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "array_onlyA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "array_onlyS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "array_onlyC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "array_onlyS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "array_onlyA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "array_onlyS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "array_onlyC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "array_onlyS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "array_onlyC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "array_onlyA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "array_onlyS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "array_onlyC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "array_onlyS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "array_onlyA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "array_onlyS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "array_onlyC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "array_onlyS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "array_onlyC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "array_onlyA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "array_onlyS_T.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
array_onlyC.inl array_onlyS.h array_onlyA.h array_onlyS_T.h array_onlyC.h array_onlyS.cpp array_onlyC.cpp array_onlyA.cpp array_onlyS_T.cpp: array_only.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -GA array_only.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
array_onlyC.inl array_onlyS.h array_onlyA.h array_onlyS_T.h array_onlyC.h array_onlyS.cpp array_onlyC.cpp array_onlyA.cpp array_onlyS_T.cpp: $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += constantsC.inl constantsS.h constantsA.h constantsS_T.h constantsC.h constantsS.cpp constantsC.cpp constantsA.cpp constantsS_T.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "constants.idl" -nt "constantsC.inl" 2> /dev/null || $(TEST_EXE) "constants.idl" -nt "constantsS.h" 2> /dev/null || $(TEST_EXE) "constants.idl" -nt "constantsA.h" 2> /dev/null || $(TEST_EXE) "constants.idl" -nt "constantsS_T.h" 2> /dev/null || $(TEST_EXE) "constants.idl" -nt "constantsC.h" 2> /dev/null || $(TEST_EXE) "constants.idl" -nt "constantsS.cpp" 2> /dev/null || $(TEST_EXE) "constants.idl" -nt "constantsC.cpp" 2> /dev/null || $(TEST_EXE) "constants.idl" -nt "constantsA.cpp" 2> /dev/null || $(TEST_EXE) "constants.idl" -nt "constantsS_T.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "constantsC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "constantsS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "constantsA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "constantsS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "constantsC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "constantsS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "constantsC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "constantsA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "constantsS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "constantsC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "constantsS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "constantsA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "constantsS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "constantsC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "constantsS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "constantsC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "constantsA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "constantsS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "constantsC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "constantsS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "constantsA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "constantsS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "constantsC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "constantsS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "constantsC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "constantsA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "constantsS_T.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
constantsC.inl constantsS.h constantsA.h constantsS_T.h constantsC.h constantsS.cpp constantsC.cpp constantsA.cpp constantsS_T.cpp: constants.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -GA constants.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
constantsC.inl constantsS.h constantsA.h constantsS_T.h constantsC.h constantsS.cpp constantsC.cpp constantsA.cpp constantsS_T.cpp: $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += generic_objectC.inl generic_objectS.h generic_objectA.h generic_objectS_T.h generic_objectC.h generic_objectS.cpp generic_objectC.cpp generic_objectA.cpp generic_objectS_T.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "generic_object.idl" -nt "generic_objectC.inl" 2> /dev/null || $(TEST_EXE) "generic_object.idl" -nt "generic_objectS.h" 2> /dev/null || $(TEST_EXE) "generic_object.idl" -nt "generic_objectA.h" 2> /dev/null || $(TEST_EXE) "generic_object.idl" -nt "generic_objectS_T.h" 2> /dev/null || $(TEST_EXE) "generic_object.idl" -nt "generic_objectC.h" 2> /dev/null || $(TEST_EXE) "generic_object.idl" -nt "generic_objectS.cpp" 2> /dev/null || $(TEST_EXE) "generic_object.idl" -nt "generic_objectC.cpp" 2> /dev/null || $(TEST_EXE) "generic_object.idl" -nt "generic_objectA.cpp" 2> /dev/null || $(TEST_EXE) "generic_object.idl" -nt "generic_objectS_T.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "generic_objectC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "generic_objectS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "generic_objectA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "generic_objectS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "generic_objectC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "generic_objectS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "generic_objectC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "generic_objectA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "generic_objectS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "generic_objectC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "generic_objectS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "generic_objectA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "generic_objectS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "generic_objectC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "generic_objectS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "generic_objectC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "generic_objectA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "generic_objectS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "generic_objectC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "generic_objectS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "generic_objectA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "generic_objectS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "generic_objectC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "generic_objectS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "generic_objectC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "generic_objectA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "generic_objectS_T.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
generic_objectC.inl generic_objectS.h generic_objectA.h generic_objectS_T.h generic_objectC.h generic_objectS.cpp generic_objectC.cpp generic_objectA.cpp generic_objectS_T.cpp: generic_object.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -GA generic_object.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
generic_objectC.inl generic_objectS.h generic_objectA.h generic_objectS_T.h generic_objectC.h generic_objectS.cpp generic_objectC.cpp generic_objectA.cpp generic_objectS_T.cpp: $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += keywordsC.inl keywordsS.h keywordsA.h keywordsS_T.h keywordsC.h keywordsS.cpp keywordsC.cpp keywordsA.cpp keywordsS_T.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "keywords.idl" -nt "keywordsC.inl" 2> /dev/null || $(TEST_EXE) "keywords.idl" -nt "keywordsS.h" 2> /dev/null || $(TEST_EXE) "keywords.idl" -nt "keywordsA.h" 2> /dev/null || $(TEST_EXE) "keywords.idl" -nt "keywordsS_T.h" 2> /dev/null || $(TEST_EXE) "keywords.idl" -nt "keywordsC.h" 2> /dev/null || $(TEST_EXE) "keywords.idl" -nt "keywordsS.cpp" 2> /dev/null || $(TEST_EXE) "keywords.idl" -nt "keywordsC.cpp" 2> /dev/null || $(TEST_EXE) "keywords.idl" -nt "keywordsA.cpp" 2> /dev/null || $(TEST_EXE) "keywords.idl" -nt "keywordsS_T.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "keywordsC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "keywordsS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "keywordsA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "keywordsS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "keywordsC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "keywordsS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "keywordsC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "keywordsA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "keywordsS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "keywordsC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "keywordsS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "keywordsA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "keywordsS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "keywordsC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "keywordsS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "keywordsC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "keywordsA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "keywordsS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "keywordsC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "keywordsS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "keywordsA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "keywordsS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "keywordsC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "keywordsS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "keywordsC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "keywordsA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "keywordsS_T.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
keywordsC.inl keywordsS.h keywordsA.h keywordsS_T.h keywordsC.h keywordsS.cpp keywordsC.cpp keywordsA.cpp keywordsS_T.cpp: keywords.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -GA keywords.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
keywordsC.inl keywordsS.h keywordsA.h keywordsS_T.h keywordsC.h keywordsS.cpp keywordsC.cpp keywordsA.cpp keywordsS_T.cpp: $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += inheritC.inl inheritS.h inheritA.h inheritS_T.h inheritC.h inheritS.cpp inheritC.cpp inheritA.cpp inheritS_T.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "inherit.idl" -nt "inheritC.inl" 2> /dev/null || $(TEST_EXE) "inherit.idl" -nt "inheritS.h" 2> /dev/null || $(TEST_EXE) "inherit.idl" -nt "inheritA.h" 2> /dev/null || $(TEST_EXE) "inherit.idl" -nt "inheritS_T.h" 2> /dev/null || $(TEST_EXE) "inherit.idl" -nt "inheritC.h" 2> /dev/null || $(TEST_EXE) "inherit.idl" -nt "inheritS.cpp" 2> /dev/null || $(TEST_EXE) "inherit.idl" -nt "inheritC.cpp" 2> /dev/null || $(TEST_EXE) "inherit.idl" -nt "inheritA.cpp" 2> /dev/null || $(TEST_EXE) "inherit.idl" -nt "inheritS_T.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "inheritC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "inheritS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "inheritA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "inheritS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "inheritC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "inheritS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "inheritC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "inheritA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "inheritS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "inheritC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "inheritS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "inheritA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "inheritS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "inheritC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "inheritS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "inheritC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "inheritA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "inheritS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "inheritC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "inheritS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "inheritA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "inheritS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "inheritC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "inheritS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "inheritC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "inheritA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "inheritS_T.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
inheritC.inl inheritS.h inheritA.h inheritS_T.h inheritC.h inheritS.cpp inheritC.cpp inheritA.cpp inheritS_T.cpp: inherit.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -GA inherit.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
inheritC.inl inheritS.h inheritA.h inheritS_T.h inheritC.h inheritS.cpp inheritC.cpp inheritA.cpp inheritS_T.cpp: $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += moduleC.inl moduleS.h moduleA.h moduleS_T.h moduleC.h moduleS.cpp moduleC.cpp moduleA.cpp moduleS_T.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "module.idl" -nt "moduleC.inl" 2> /dev/null || $(TEST_EXE) "module.idl" -nt "moduleS.h" 2> /dev/null || $(TEST_EXE) "module.idl" -nt "moduleA.h" 2> /dev/null || $(TEST_EXE) "module.idl" -nt "moduleS_T.h" 2> /dev/null || $(TEST_EXE) "module.idl" -nt "moduleC.h" 2> /dev/null || $(TEST_EXE) "module.idl" -nt "moduleS.cpp" 2> /dev/null || $(TEST_EXE) "module.idl" -nt "moduleC.cpp" 2> /dev/null || $(TEST_EXE) "module.idl" -nt "moduleA.cpp" 2> /dev/null || $(TEST_EXE) "module.idl" -nt "moduleS_T.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "moduleC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "moduleS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "moduleA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "moduleS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "moduleC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "moduleS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "moduleC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "moduleA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "moduleS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "moduleC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "moduleS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "moduleA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "moduleS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "moduleC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "moduleS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "moduleC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "moduleA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "moduleS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "moduleC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "moduleS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "moduleA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "moduleS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "moduleC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "moduleS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "moduleC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "moduleA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "moduleS_T.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
moduleC.inl moduleS.h moduleA.h moduleS_T.h moduleC.h moduleS.cpp moduleC.cpp moduleA.cpp moduleS_T.cpp: module.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -GA module.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
moduleC.inl moduleS.h moduleA.h moduleS_T.h moduleC.h moduleS.cpp moduleC.cpp moduleA.cpp moduleS_T.cpp: $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += primtypesC.inl primtypesS.h primtypesA.h primtypesS_T.h primtypesC.h primtypesS.cpp primtypesC.cpp primtypesA.cpp primtypesS_T.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "primtypes.idl" -nt "primtypesC.inl" 2> /dev/null || $(TEST_EXE) "primtypes.idl" -nt "primtypesS.h" 2> /dev/null || $(TEST_EXE) "primtypes.idl" -nt "primtypesA.h" 2> /dev/null || $(TEST_EXE) "primtypes.idl" -nt "primtypesS_T.h" 2> /dev/null || $(TEST_EXE) "primtypes.idl" -nt "primtypesC.h" 2> /dev/null || $(TEST_EXE) "primtypes.idl" -nt "primtypesS.cpp" 2> /dev/null || $(TEST_EXE) "primtypes.idl" -nt "primtypesC.cpp" 2> /dev/null || $(TEST_EXE) "primtypes.idl" -nt "primtypesA.cpp" 2> /dev/null || $(TEST_EXE) "primtypes.idl" -nt "primtypesS_T.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "primtypesC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "primtypesS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "primtypesA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "primtypesS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "primtypesC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "primtypesS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "primtypesC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "primtypesA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "primtypesS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "primtypesC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "primtypesS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "primtypesA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "primtypesS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "primtypesC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "primtypesS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "primtypesC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "primtypesA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "primtypesS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "primtypesC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "primtypesS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "primtypesA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "primtypesS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "primtypesC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "primtypesS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "primtypesC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "primtypesA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "primtypesS_T.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
primtypesC.inl primtypesS.h primtypesA.h primtypesS_T.h primtypesC.h primtypesS.cpp primtypesC.cpp primtypesA.cpp primtypesS_T.cpp: primtypes.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -GA primtypes.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
primtypesC.inl primtypesS.h primtypesA.h primtypesS_T.h primtypesC.h primtypesS.cpp primtypesC.cpp primtypesA.cpp primtypesS_T.cpp: $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += pragmaC.inl pragmaS.h pragmaA.h pragmaS_T.h pragmaC.h pragmaS.cpp pragmaC.cpp pragmaA.cpp pragmaS_T.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "pragma.idl" -nt "pragmaC.inl" 2> /dev/null || $(TEST_EXE) "pragma.idl" -nt "pragmaS.h" 2> /dev/null || $(TEST_EXE) "pragma.idl" -nt "pragmaA.h" 2> /dev/null || $(TEST_EXE) "pragma.idl" -nt "pragmaS_T.h" 2> /dev/null || $(TEST_EXE) "pragma.idl" -nt "pragmaC.h" 2> /dev/null || $(TEST_EXE) "pragma.idl" -nt "pragmaS.cpp" 2> /dev/null || $(TEST_EXE) "pragma.idl" -nt "pragmaC.cpp" 2> /dev/null || $(TEST_EXE) "pragma.idl" -nt "pragmaA.cpp" 2> /dev/null || $(TEST_EXE) "pragma.idl" -nt "pragmaS_T.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "pragmaC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "pragmaS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "pragmaA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "pragmaS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "pragmaC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "pragmaS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "pragmaC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "pragmaA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "pragmaS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "pragmaC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "pragmaS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "pragmaA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "pragmaS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "pragmaC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "pragmaS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "pragmaC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "pragmaA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "pragmaS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "pragmaC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "pragmaS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "pragmaA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "pragmaS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "pragmaC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "pragmaS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "pragmaC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "pragmaA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "pragmaS_T.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
pragmaC.inl pragmaS.h pragmaA.h pragmaS_T.h pragmaC.h pragmaS.cpp pragmaC.cpp pragmaA.cpp pragmaS_T.cpp: pragma.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -GA pragma.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
pragmaC.inl pragmaS.h pragmaA.h pragmaS_T.h pragmaC.h pragmaS.cpp pragmaC.cpp pragmaA.cpp pragmaS_T.cpp: $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += repo_id_modC.inl repo_id_modS.h repo_id_modA.h repo_id_modS_T.h repo_id_modC.h repo_id_modS.cpp repo_id_modC.cpp repo_id_modA.cpp repo_id_modS_T.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "repo_id_mod.idl" -nt "repo_id_modC.inl" 2> /dev/null || $(TEST_EXE) "repo_id_mod.idl" -nt "repo_id_modS.h" 2> /dev/null || $(TEST_EXE) "repo_id_mod.idl" -nt "repo_id_modA.h" 2> /dev/null || $(TEST_EXE) "repo_id_mod.idl" -nt "repo_id_modS_T.h" 2> /dev/null || $(TEST_EXE) "repo_id_mod.idl" -nt "repo_id_modC.h" 2> /dev/null || $(TEST_EXE) "repo_id_mod.idl" -nt "repo_id_modS.cpp" 2> /dev/null || $(TEST_EXE) "repo_id_mod.idl" -nt "repo_id_modC.cpp" 2> /dev/null || $(TEST_EXE) "repo_id_mod.idl" -nt "repo_id_modA.cpp" 2> /dev/null || $(TEST_EXE) "repo_id_mod.idl" -nt "repo_id_modS_T.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "repo_id_modC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "repo_id_modS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "repo_id_modA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "repo_id_modS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "repo_id_modC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "repo_id_modS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "repo_id_modC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "repo_id_modA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "repo_id_modS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "repo_id_modC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "repo_id_modS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "repo_id_modA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "repo_id_modS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "repo_id_modC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "repo_id_modS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "repo_id_modC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "repo_id_modA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "repo_id_modS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "repo_id_modC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "repo_id_modS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "repo_id_modA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "repo_id_modS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "repo_id_modC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "repo_id_modS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "repo_id_modC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "repo_id_modA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "repo_id_modS_T.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
repo_id_modC.inl repo_id_modS.h repo_id_modA.h repo_id_modS_T.h repo_id_modC.h repo_id_modS.cpp repo_id_modC.cpp repo_id_modA.cpp repo_id_modS_T.cpp: repo_id_mod.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -GA repo_id_mod.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
repo_id_modC.inl repo_id_modS.h repo_id_modA.h repo_id_modS_T.h repo_id_modC.h repo_id_modS.cpp repo_id_modC.cpp repo_id_modA.cpp repo_id_modS_T.cpp: $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += typedefC.inl typedefS.h typedefA.h typedefS_T.h typedefC.h typedefS.cpp typedefC.cpp typedefA.cpp typedefS_T.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "typedef.idl" -nt "typedefC.inl" 2> /dev/null || $(TEST_EXE) "typedef.idl" -nt "typedefS.h" 2> /dev/null || $(TEST_EXE) "typedef.idl" -nt "typedefA.h" 2> /dev/null || $(TEST_EXE) "typedef.idl" -nt "typedefS_T.h" 2> /dev/null || $(TEST_EXE) "typedef.idl" -nt "typedefC.h" 2> /dev/null || $(TEST_EXE) "typedef.idl" -nt "typedefS.cpp" 2> /dev/null || $(TEST_EXE) "typedef.idl" -nt "typedefC.cpp" 2> /dev/null || $(TEST_EXE) "typedef.idl" -nt "typedefA.cpp" 2> /dev/null || $(TEST_EXE) "typedef.idl" -nt "typedefS_T.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "typedefC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "typedefS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "typedefA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "typedefS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "typedefC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "typedefS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "typedefC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "typedefA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "typedefS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "typedefC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "typedefS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "typedefA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "typedefS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "typedefC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "typedefS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "typedefC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "typedefA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "typedefS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "typedefC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "typedefS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "typedefA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "typedefS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "typedefC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "typedefS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "typedefC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "typedefA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "typedefS_T.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
typedefC.inl typedefS.h typedefA.h typedefS_T.h typedefC.h typedefS.cpp typedefC.cpp typedefA.cpp typedefS_T.cpp: typedef.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -GA typedef.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
typedefC.inl typedefS.h typedefA.h typedefS_T.h typedefC.h typedefS.cpp typedefC.cpp typedefA.cpp typedefS_T.cpp: $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += typecodeC.inl typecodeS.h typecodeA.h typecodeS_T.h typecodeC.h typecodeS.cpp typecodeC.cpp typecodeA.cpp typecodeS_T.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "typecode.idl" -nt "typecodeC.inl" 2> /dev/null || $(TEST_EXE) "typecode.idl" -nt "typecodeS.h" 2> /dev/null || $(TEST_EXE) "typecode.idl" -nt "typecodeA.h" 2> /dev/null || $(TEST_EXE) "typecode.idl" -nt "typecodeS_T.h" 2> /dev/null || $(TEST_EXE) "typecode.idl" -nt "typecodeC.h" 2> /dev/null || $(TEST_EXE) "typecode.idl" -nt "typecodeS.cpp" 2> /dev/null || $(TEST_EXE) "typecode.idl" -nt "typecodeC.cpp" 2> /dev/null || $(TEST_EXE) "typecode.idl" -nt "typecodeA.cpp" 2> /dev/null || $(TEST_EXE) "typecode.idl" -nt "typecodeS_T.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "typecodeC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "typecodeS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "typecodeA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "typecodeS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "typecodeC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "typecodeS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "typecodeC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "typecodeA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "typecodeS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "typecodeC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "typecodeS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "typecodeA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "typecodeS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "typecodeC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "typecodeS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "typecodeC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "typecodeA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "typecodeS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "typecodeC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "typecodeS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "typecodeA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "typecodeS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "typecodeC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "typecodeS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "typecodeC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "typecodeA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "typecodeS_T.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
typecodeC.inl typecodeS.h typecodeA.h typecodeS_T.h typecodeC.h typecodeS.cpp typecodeC.cpp typecodeA.cpp typecodeS_T.cpp: typecode.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -GA typecode.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
typecodeC.inl typecodeS.h typecodeA.h typecodeS_T.h typecodeC.h typecodeS.cpp typecodeC.cpp typecodeA.cpp typecodeS_T.cpp: $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

ifneq ($(GENERATED_DIRTY),)
.PRECIOUS: $(GENERATED_DIRTY)
ifeq ($(corba_messaging),1)
all: $(GENERATED_DIRTY)
endif
endif

ADDITIONAL_IDL_TARGETS += attribute$(IDL_CLIENT_HDR_EXT) Bug_2350_Regression$(IDL_CLIENT_HDR_EXT) Bug_2577_Regression$(IDL_CLIENT_HDR_EXT) Bug_2582_Regression$(IDL_CLIENT_HDR_EXT) Bug_2583_Regression$(IDL_CLIENT_HDR_EXT) Bug_2616_Regression$(IDL_CLIENT_HDR_EXT) Bug_2619_Regression$(IDL_CLIENT_HDR_EXT) Bug_3243_Regression$(IDL_CLIENT_HDR_EXT) Bug_3312_Regression$(IDL_CLIENT_HDR_EXT) Bug_3819_Regression$(IDL_CLIENT_HDR_EXT) Bug_3821_Regression$(IDL_CLIENT_HDR_EXT) full$(IDL_CLIENT_HDR_EXT) fwd$(IDL_CLIENT_HDR_EXT) gperf$(IDL_CLIENT_HDR_EXT) interface$(IDL_CLIENT_HDR_EXT) nested_scope$(IDL_CLIENT_HDR_EXT) old_constants$(IDL_CLIENT_HDR_EXT) simple$(IDL_CLIENT_HDR_EXT) simple2$(IDL_CLIENT_HDR_EXT) old_array$(IDL_CLIENT_HDR_EXT) old_sequence$(IDL_CLIENT_HDR_EXT) old_struct$(IDL_CLIENT_HDR_EXT) old_union$(IDL_CLIENT_HDR_EXT) old_union2$(IDL_CLIENT_HDR_EXT) params$(IDL_CLIENT_HDR_EXT) reopened_modules$(IDL_CLIENT_HDR_EXT) struct$(IDL_CLIENT_HDR_EXT) reopen_include1$(IDL_CLIENT_HDR_EXT) reopen_include2$(IDL_CLIENT_HDR_EXT) typeprefix$(IDL_CLIENT_HDR_EXT) enum_in_struct$(IDL_CLIENT_HDR_EXT) array$(IDL_CLIENT_HDR_EXT) array_anon_nested$(IDL_CLIENT_HDR_EXT) included$(IDL_CLIENT_HDR_EXT) including$(IDL_CLIENT_HDR_EXT) sequence$(IDL_CLIENT_HDR_EXT) union$(IDL_CLIENT_HDR_EXT) anyunion$(IDL_CLIENT_HDR_EXT) valuetype$(IDL_CLIENT_HDR_EXT) anonymous$(IDL_CLIENT_HDR_EXT) dif2$(IDL_CLIENT_HDR_EXT) array_only$(IDL_CLIENT_HDR_EXT) constants$(IDL_CLIENT_HDR_EXT) generic_object$(IDL_CLIENT_HDR_EXT) keywords$(IDL_CLIENT_HDR_EXT) inherit$(IDL_CLIENT_HDR_EXT) module$(IDL_CLIENT_HDR_EXT) primtypes$(IDL_CLIENT_HDR_EXT) pragma$(IDL_CLIENT_HDR_EXT) repo_id_mod$(IDL_CLIENT_HDR_EXT) typedef$(IDL_CLIENT_HDR_EXT) typecode$(IDL_CLIENT_HDR_EXT)
idl_stubs: $(ADDITIONAL_IDL_TARGETS)


realclean: clean
ifneq ($(GENERATED_DIRTY),)
	-$(RM) -r $(GENERATED_DIRTY)
endif

__prebuild__:
ifeq ($(corba_messaging),1)
	@-:
endif


.PHONY: install
install: all
INSTALL_LIB ?= lib
ifneq ($(INSTALL_PREFIX),)
ifneq ($(install_rpath),0)
LDFLAGS += -Wl,-R$(INSTALL_PREFIX)/$(INSTALL_LIB) $(LD_RPATH_FLAGS)
endif
endif


